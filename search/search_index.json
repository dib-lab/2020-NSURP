{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"NSURP Research Project 2020","text":"<p>The materials in this repository are designed to facilitate learning bioinformatic techniques while working through a metagenomics project using publicly-available data. If you see a mistake or something is not clear, please submit an issue. </p> <p>During this project, you will learn how to:</p> <ul> <li>keep a detailed lab notebook</li> <li>interact with an HPC (we'll use Farm)</li> <li>install and manage software environments using conda</li> <li>download sequencing data and other files from the internet and public databases</li> <li>interpret and use different file formats in bioinformatics and computing</li> <li>conduct quality analysis and control for sequencing data</li> <li>determine the taxonomic composition of sequencing reads</li> <li>quickly compare large sequencing datasets</li> <li>build reproducible workflows using snakemake</li> <li>document workflows using git and GitHub</li> <li>troubleshoot errors during your analysis</li> </ul> <p>Most of the work done in this rotation will be completed on Farm.  However, you will need to access Farm from your own computer.  We will use an SSH-client to be able to interact with Farm.  If you are using a Mac or running Linux, your computer comes with a program (e.g. <code>Terminal</code> on Mac) that we can use as an SSH-client. If you are on a Windows running Windows 10, you can install the Ubuntu Subsystem. Otherwise, please follow the instructions for Windows found at this link.</p>"},{"location":"00.getting-started/","title":"NSURP Research Project 2020","text":"<p>This repository contains step-by-step resources for running a metagenomics workflow.  If you see a mistake or something is not clear, please submit an issue. </p> <p>During this project, you will learn how to:  + interact with an HPC (we'll use Farm)  + install and manage software environments using conda  + download sequencing data and other files from the internet and public databases  + interpret and use different file formats in bioinformatics and computing  + quality analysis and control for sequencing data  + determine the taxonomic composition of sequencing reads  + assemble and annotate metagenomic reads  + quickly compare large sequencing datasets  + document workflows using git and GitHub. </p> <p>The files in this repository are ordered by execution, meaning file <code>00*</code> should be completed before <code>01*</code>. </p> <p>Most of the work done in this rotation will be completed on Farm.  However, you will need to access Farm from your own computer.  We will use an SSH-client to be able to interact with Farm.  If you are using a Mac or a Linux, your computer comes with a program called <code>Terminal</code> that we will use as an SSH-client. If you are on a Windows running Windows 10, you can install the Ubuntu Subsystem. Otherwise, please follow the instructions for Windows found at this link.</p>"},{"location":"01.using-farm/","title":"Getting Started on the Farm HPC","text":"<p>High Performance Computing (HPC) refers to computers that have more capability than a typical personal computer  (i.e. most desktops and laptops).  Many research problems we encounter when analyzing sequencing data require more resources than we have available on our laptops. For this, we use large, remote compute systems that have more resources available. </p> <p>Most universities have access to an HPC (or cluster) that has a large amount of hard drive space to store files, RAM for computing tasks, and CPUs for processing. Other options for accessing large computers include NSF XSEDE services like Jetstream and paid services like Amazon Web Services or Google Cloud. We will use the UC Davis Farm Cluster during this rotation.</p>"},{"location":"01.using-farm/#getting-an-account-on-farm","title":"Getting an account on Farm","text":"<p>To be able to use Farm, you need to sign up for an account.  Farm requires key file authentication. Key files come in pairs like the locks and keys on doors.  The private key file is the first file, and it is like the key to a door.  This file is private and should never be shared with anyone (do not post this file on GitHub, slack, etc.).  The public key file is the second file, and it is like the lock on a door. It is publicly viewable, but cannot be \"unlocked\" without the private key file. </p> <p>We need to generate a key file pair in order to create a farm account. </p> <p>Open the <code>Terminal</code> application or the Terminal emulator you installed in the first_lesson.</p> <p>Change directories into the <code>.ssh</code> folder. This folder is where key file pairs are typically stored.</p> <pre><code>cd ~/.ssh\n</code></pre> <p>If this command does not work, create your own <code>ssh</code> folder and <code>cd</code> into it:</p> <pre><code>mkdir -p ~/.ssh\ncd ~/.ssh\n</code></pre> <p>Then, generate the keyfile pair by running:</p> <pre><code>ssh-keygen\n</code></pre> <p>Follow the prompts on the screen. If prompted for a password, you can hit <code>Enter</code> on your keyboard to avoid setting one.</p> <p>Two files will be created by this command.  These files should have the same prefix. The file that ends in <code>.pub</code> is the public key.</p>"},{"location":"01.using-farm/#the-account-request-form","title":"The account request form","text":"<p>Next, navigate to this page. From the first drop down menu (Which cluster are you applying for an account on?), select <code>FARM/CAES</code>. From the second drop down menu (Who is sponsoring your account?), select <code>Brown, C. Titus</code>. Then, upload your public key file to the page.  Submit the form.  If the cluster admins and Titus approve your account, you will now have farm access! Don't loose the key file pair you just made.  You will need the private key file each time you log into farm.</p>"},{"location":"01.using-farm/#connecting-to-a-remote-computer","title":"Connecting to a remote computer","text":"<p>Once you have a farm account, we will use the command <code>ssh</code> to connect to farm.  <code>ssh</code> stands for \"secure shell\". </p> <p>To connect to your account on farm, type:</p> <pre><code>ssh -i ~/.ssh/your_keyfile_name username@farm.cse.ucdavis.edu\n</code></pre> <p>If you are successful, you will see a message that looks something like this:</p> <pre><code>Welcome to Ubuntu 18.04.3 LTS (GNU/Linux 4.15.0-70-generic x86_64)\n\n1 updates could not be installed automatically. For more details,\nsee /var/log/unattended-upgrades/unattended-upgrades.log\n\n*** System restart required ***\nA transfer node, c11-42, is available for rsync, scp, gzip\nFrom outside the Farm cluster use port 2022 to access the transfer node.\n ssh -p 2022 username@farm.cse.ucdavis.edu\n scp -P 2022 src username@farm.cse.ucdavis.edu:/destination\n\n   REMINDER: Farm does not back up user data. Please ensure your data is backed up offsite.\n\n *** Dec 04 2019:\n * 2:10pm - Service restored. Please report any issues to help@cse.ucdavis.edu.\n\n\n   Email help@cse.ucdavis.edu for help with Farm.\n\nDowntime scheduled for the first Wednesday of Oct and April.  The next downtime is Wednesday April 1st at 11:59pm.\n\nIf interested in contributing to farm, the rates for 5 years are:\n  $ 1,000 per 10TB, served from redundant servers with compression\n  $ 8,800 per parallel node (256GB ram, 32 cores/64 threads, 2TB /scratch)\n  $17,500 per GPU node (Nvidia Telsa V100, dual Xeon 4114, 2TB /scratch)\n  $22,700 per bigmem node (1TB ram, 48 cores/96 threads, 2TB /scratch)\n\nLast login: Thu Jan  2 17:01:36 2020 from 76.105.143.194\nModule slurm/19.05.3 loaded\nModule openmpi/4.0.1 loaded\nusername@farm:~$\n</code></pre> <p>When you first login to farm, you will be in your home directory. This is where you will write your files and run the majority of your commands. </p> <p>When you are done using farm, you can exit your ssh connection with the <code>exit</code> command.</p> <pre><code>exit\n</code></pre>"},{"location":"02.conda/","title":"Using Conda for Software Installation","text":"<p>This section covers using conda to install scientific software.</p>"},{"location":"02.conda/#what-is-conda","title":"What is Conda?","text":"<p>Installing scientific software (including all required dependencies of said software!) is often challenging. Conda is a software manager that helps you find and install software packages.</p>"},{"location":"02.conda/#set-up-miniconda","title":"Set up Miniconda","text":"<p>To get started, we'll install miniconda, which contains everything we need to get started with conda.</p> <p>Log in to farm and run the following commands to install Miniconda.  Follow the prompts on the screen and accept all default options.</p>"},{"location":"02.conda/#install-conda","title":"Install conda","text":"<pre><code>wget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh\nbash Miniconda3-latest-Linux-x86_64.sh\n</code></pre> <p>Again, be sure to answer <code>yes</code> to any yes/no questions, especially the last question about <code>conda init</code>! This will ensure conda is fully installed and you'll be able to use it for the commands below.</p>"},{"location":"02.conda/#copy-bashrc-code-to-bash_profile","title":"Copy .bashrc code to .bash_profile","text":"<p>FARM runs <code>.bash_profile</code> on startup (not <code>.bashrc</code>). Here, we explicitly run the <code>.bashrc</code> from the <code>.bash_profile</code> file</p> <pre><code>echo source ~/.bashrc &gt;&gt; ~/.bash_profile\n</code></pre>"},{"location":"02.conda/#activate-conda","title":"Activate conda","text":"<p>Miniconda is now installed, but we need to activate it to be able to use it.</p> <pre><code>source ~/.bashrc\n</code></pre> <p>This command executes our <code>~/.bashrc</code> command, which should now have</p> <p>You should now see <code>(base)</code> in front of your prompt, indicating that you are in the base environment.</p>"},{"location":"02.conda/#optional-add-colors-to-your-terminal-output","title":"Optional: Add colors to your terminal output","text":"<p>If you have preferred settings for bash, go ahead and set them up.</p> <p>Open the <code>.bash_profile</code> file using <code>nano</code></p> <pre><code>cd\nnano .bash_profile\n</code></pre> <p>Now, add the following to the document:</p> <pre><code>export PS1=\"\\[\\033[36m\\]\\u\\[\\033[m\\]@\\[\\033[32m\\]\\h:\\[\\033[33;1m\\]\\w\\[\\033[m\\]\\$\"\nexport CLICOLOR=1\nexport LSCOLORS=ExFxBxDxCxegedabagacad\nalias ls='ls --color=auto'\n</code></pre> <p>And close and save the document (<code>Ctrl-X</code>, <code>Y</code>, <code>&lt;Enter&gt;</code>)</p> <p>Now source the file:</p> <pre><code>source .bash_profile\n</code></pre> <p>Try an <code>ls</code>! Is your <code>miniconda3</code> folder a different color than the <code>Miniconda3-latest-Linux-x86_64.sh</code> installer?</p>"},{"location":"02.conda/#configuring-channels","title":"Configuring channels","text":"<p>Conda works by searching for software packages in online repositories (Channels). By default, conda searches for software only in Continuum\u2019s (Conda\u2019s developer) channels.</p> <p>Most of the scientific software we'll be using is not available within the default channel, so we will add additional channels to our conda settings.</p> <p>Channels in Conda are ordered.  The channel with the highest priority is the first one that Conda checks, looking for the package you asked for.  You can change this order, and also add channels to it (and set their priority as well).</p> <p>If multiple channels contain a package, and one channel contains a newer version than the other one, the order of the channels\u2019 determines which one of these two versions are going to be installed, even if the higher priority channel contains the older version.</p> <pre><code>conda config --add channels defaults\nconda config --add channels bioconda\nconda config --add channels conda-forge\n</code></pre> <p>Note that these commands stack. In this case, the highest priority channel will be <code>conda-forge</code>, followed by <code>bioconda</code> and then the <code>defaults</code> channel.</p> <p>So when installing software, conda will start by looking for our desired software packing in the <code>conda-forge</code> channel, then search in the <code>bioconda</code> channel, and finally search in the <code>defaults</code> channel.</p>"},{"location":"02.conda/#using-conda-environments","title":"Using Conda environments","text":"<p>Different software packages often have different \"dependencies\": other software packages that are required for installation. In many cases, you'll need software with dependencies that conflict -- e.g. one program requires python version 3, while the other requires python 2. To avoid conflicts, we install software into \"environments\" that are isolated from one another - so that the software installed in one environment does not impact the software installed in another environment.</p>"},{"location":"02.conda/#create-an-environment","title":"Create an environment","text":"<p>Let's start by creating an environment for this project</p> <pre><code>conda create -y --name nsurp-env\n</code></pre> <p>This creates an empty environment named <code>nsurp-env</code>. To activate this environment, run:</p> <pre><code>conda activate nsurp-env\n</code></pre> <p>Your prompt should now start with <code>(nsurp-env)</code>.</p>"},{"location":"02.conda/#install-software-into-the-environment","title":"Install software into the environment","text":"<p>We can now install software into our environment.  Let's install sourmash, which we will use in a later lesson. </p> <pre><code>conda install -y sourmash\n</code></pre>"},{"location":"02.conda/#deactivating-and-exiting","title":"Deactivating and Exiting","text":"<p>When you'd like to leave your environment, you can type <code>conda deactivate</code> and you will return to the base environment.</p> <p>When you log out of farm by typing <code>exit</code>, when you end a <code>tmux</code> or <code>screen</code> session, or when an <code>srun</code> job ends, your environment will automatically be deactivated. To restart the environment, you can run <code>conda activate nsurp-env</code>.</p>"},{"location":"02.conda/#additional-resources","title":"Additional Resources","text":"<p>This tutorial covers the basics of conda including a brief introduction to conda and why it is useful, installation and setup, creating environments, and installing software. </p> <p>These videos cover the material in the above tutorial: </p> <ul> <li>video 1</li> <li>video 2 (there were some technical issues with this recording...sorry!)</li> </ul>"},{"location":"03.lab-notebook/","title":"Keeping a Lab Notebook","text":"<p>Just like with wetlab work, it's important to document everything you do during a computational workflow. </p>"},{"location":"03.lab-notebook/#where-to-take-notes","title":"Where to take notes","text":"<p>For this project, we recommend using HackMD. HackMD works a little like google docs, but enables better formatting for adding code. You can start with just regular text, but as you start adding screnshots, code blocks, and header sections, you can use Markdown syntax to improve formatting of your rendered notes. HackMD shows you a few examples of Markdown when you first open a new document, but you can also check out this markdown tutorial if you want to learn more.</p>"},{"location":"03.lab-notebook/#how-to-take-notes","title":"How to take notes","text":"<p>It's ok to provide the minimum amount of information necessary to execute a set of commands (i.e., you don't necessary have to record every failure, every <code>ls</code>, etc), but it is important to document each step. + Copying and pasting the commands that worked is a great way to record them (the <code>history</code> command can be helpful to see what you've run in the past).</p>"},{"location":"03.lab-notebook/#documentation-is-for-you-and-also-for-others","title":"Documentation is for you! (And also for others)","text":"<p>Your lab notebook and documentation is most useful for future you. Keep in mind that things that seem super obvious right now will likely be forgetten within a few weeks/months. Try to be detailed enough so that if you tried to pick up this project again in 3 months (or 3 years), you would be able to understand exactly what to do and how to do it. With a good lab notebook, you can save yourself from troubleshooting the same errors over and over again, as well as greatly simplify the process of writing up your <code>Materials and Methods</code> section for any reports or papers. Finally, good lab notebooks help keep everyone working on your project (both now and in the future) on the same page.</p>"},{"location":"03.lab-notebook/#other-systems-for-taking-notes","title":"Other systems for taking notes:","text":"<p>After this project, if you like HackMD, great! Stick with it. If not:</p> <ul> <li>Using google docs or Microsoft Word for documenting computer commands can be hard because of autocorrection. We generally recommend against using these programs.</li> <li>Using a plain text editor (Notepad, Notepad++, Atom, BBEdit, TextEdit, nano, vim) avoids autocorrect problems but still has a nice user interface.</li> <li>Jupyter Lab is very useful for interactive research explorations and notetaking. We'll try this out in a later section.</li> </ul> <p>Eventually, we'll work through using git and GitHub to record and version control our workflows, but for now it's enough to write down everything you do.</p>"},{"location":"04.sourmash-tutorial/","title":"Getting started with Sourmash: a tutorial","text":"<p>Let's go through a sourmash tutorial.</p> <p>Commands (as of 07/31/2020) reproduced here. If doing this at a later date and these commands don't work, run the tutorial using the link above instead!!</p>"},{"location":"04.sourmash-tutorial/#making-signatures-comparing-and-searching","title":"Making signatures, comparing, and searching","text":"<p>7/31/20 You'll need about 5 GB of free disk space, and about 5 GB of RAM to search GenBank. </p> <p>First activate your conda envionment:</p> <pre><code>conda activate tutorial\n</code></pre> <p>Because we installed sourmash into our <code>tutorial</code> environment, you should now be able to use the <code>sourmash</code> command:</p> <pre><code>sourmash info\n</code></pre>"},{"location":"04.sourmash-tutorial/#download-the-data-and-put-it-in-a-folder","title":"Download the data and put it in a folder","text":"<p>Lets make some folders to keep our project organized:</p> <pre><code>mkdir smtut\ncd smtut\n</code></pre> <pre><code>mkdir data\ncd data\n</code></pre> <p>Now we can download some data into our <code>data</code> folder</p> <pre><code>wget https://s3.amazonaws.com/public.ged.msu.edu/ecoli_ref-5m.fastq.gz\nwget https://s3.amazonaws.com/public.ged.msu.edu/ecoliMG1655.fa.gz\n</code></pre> <p>OR</p> <pre><code>wget https://bit.ly/2CXj13R -O ecoli_ref-5m.fastq.gz\nwget https://bit.ly/2PdRbCJ -O ecoliMG1655.fa.gz\n\n</code></pre> <p>The file that ends in <code>.fastq.gz</code> is a zipped file with DNA sequences in fastq format</p> <p>Lets take a look at our data:</p> <p>first we can unzip the fastq file,</p> <pre><code>gunzip --keep ecoli_ref-5m.fastq.gz\n\n</code></pre> <p>and use <code>ls -lh</code> to compare the sizes the zipped file should be smaller than the unzipped file</p> <p>we can look at the unzipped file using </p> <pre><code>less ecoli_ref-5m.fastq\n</code></pre> <p>it will have this fastq format: </p>"},{"location":"04.sourmash-tutorial/#computing-a-sourmash-signature","title":"Computing a sourmash signature","text":"<p>Compute a scaled signature from our reads:</p> <p>first, lets make a folder to keep our signatures in</p> <pre><code>mkdir ~/smtut/sigs\ncd ~/smtut/sigs\n</code></pre>"},{"location":"04.sourmash-tutorial/#compare-reads-to-assemblies","title":"Compare reads to assemblies","text":"<p>how much of the read content is contained in the reference genome?</p> <p>Build a signature for the E. coli reads with <code>sourmash compute</code>, </p> <pre><code>sourmash compute \\\n--scaled 10000 \\\n~/smtut/data/ecoli_ref*.fastq.gz \\\n-o ~/smtut/sigs/ecoli-reads.sig \\\n-k 31\n</code></pre> <p>Next build a signature for the E. coli genome with <code>sourmash compute</code>, </p> <pre><code>sourmash compute \\\n--scaled 10000 \\\n~/smtut/data/ecoliMG1655.fa.gz  \\\n-o ~/smtut/sigs/ecoli-genome.sig \\\n-k 31\n</code></pre> <p>this command will call the software to make a kmer signature,  keep only 1 in 10000 kmers from the sequence, store the signature where we ask it to, and use a k size of 31</p> <p>Now evaluate containment, that is, what fraction of the read content is contained in the genome:</p> <pre><code>sourmash search -k 31 ecoli-reads.sig ecoli-genome.sig --containment\n</code></pre> <p>and you should see:</p> <pre><code># running sourmash subcommand: search\nloaded query: /home/ubuntu/data/ecoli_ref-5m... (k=31, DNA)\nloaded 1 signatures from ecoli-genome.sig\n1 matches:\nsimilarity   match\n----------   -----\n 10.6%       /home/ubuntu/data/ecoliMG1655.fa.gz\n</code></pre> <p>Try the reverse - why is it bigger?</p> <pre><code>sourmash search -k 31 ecoli-genome.sig ecoli-reads.sig --containment\n</code></pre>"},{"location":"05.starting-a-work-session/","title":"Starting a Work Session on FARM","text":"<p>Any time you log onto FARM to work on this project, follow these steps to get access to computing resources.</p>"},{"location":"05.starting-a-work-session/#1-enter-a-tmux-session","title":"1. Enter a <code>tmux</code> session","text":"<p>This command creates a new <code>tmux</code> session:</p> <pre><code>tmux new -s nsurp\n</code></pre> <p>Note: If you already created this session, and want to re-join it, use <code>tmux attach</code> instead.</p>"},{"location":"05.starting-a-work-session/#2-get-access-to-a-compute-node","title":"2. Get access to a compute node","text":"<p>When you log on to our <code>FARM</code> computing system, you'll be on a <code>login</code> node, which is basically a computer with very few resources. These login nodes are shared among all users on farm. </p> <p>If we run any computing on these login nodes, logging into and navigating farm will slow down for everyone else! Instead, the moment that we want to do anything substantial, we want to ask farm for a more capable comptuter. Farm uses a \"job scheduler\" to make sure everyone gets access to the computational resources that they need.</p> <p>We can use the following command to get access to a computer that will fit our needs:</p> <pre><code>srun -p bmm -J nsurp-analysis -t 5:00:00 --mem=10G --pty bash\n</code></pre> <ul> <li><code>srun</code> uses the computer's job scheduler <code>SLURM</code> to allocate you a computer</li> <li><code>-p</code> specifies the job queue we want to use, and is specific to our <code>farm</code> accounts.</li> <li><code>-J nsurp-analysis</code> is the \"job name\" assigned to this session. It can be modified to give your session a more descriptive name, e.g. <code>-J download-data</code></li> <li><code>-t</code> denotes that we want the computer for that amount of time (in this case, 3 hours).</li> <li><code>--mem</code> specifies the amount of memory we'd like the computer to have. Here we've asked for 10 Gigabytes (10G). </li> <li><code>--pty bash</code> specified that we want the linux shell to be the <code>bash</code> shell, which is the standard shell we've been working wiht so far</li> </ul> <p>Note that your home directory (the files you see) will be the same for both the login node and the computer you get access to. This is because both read and write from the same hard drives. So you can create files while in an <code>srun</code> session, and they'll still be there for you when you logout.</p>"},{"location":"05.starting-a-work-session/#3-activate-your-conda-environment","title":"3. Activate your Conda Environment","text":"<p>Once you're in an <code>srun</code> session, activate your project environment to get access to the software you've installed</p> <pre><code>conda activate nsurp-env\n</code></pre>"},{"location":"05.starting-a-work-session/#leaving-your-tmux-session","title":"Leaving your tmux session","text":"<p>Exit tmux by <code>Ctrl-b</code>, <code>d</code></p>"},{"location":"05.starting-a-work-session/#reattaching-to-your-tmux-session","title":"Reattaching to your tmux session","text":"<pre><code>tmux attach\n</code></pre> <p>Note: if you make more than one tmux session, you can see all session names by typing <code>tmux ls</code>, and then attaching to the right one with <code>tmux attach -t &lt;NAME&gt;</code></p>"},{"location":"06.download-assess-ibd-data/","title":"Download and Visually Assess the Data","text":"<p>Metagenomics is the analysis of genetic material from environmental samples (\"environment\" here meaning anything from human gut to open ocean).  Metagenomics (DNA sequencing) and metatranscriptomics (RNA sequencing) can be used to assess the composition and functional potential of microbial commmunities.</p> <p>Human-associated microbial communities, such as the trillions of microorganisms that colonize the human gut, have co-evolved with humans and play important roles both in human biology and disease. Gut symbionts contribute to human digestive and metabolic functions, immune system regulation, and regulation of the intestinal epithelial barrier, including providing protection against pathogens.</p> <p>Inflammatory bowel disease (IBD) is an umbrella term used for diseases (Crohn's disease, Ulcerative Colitis) characterized by chronic inflammation of the intestines. These diseases impact about 3 million people in the United States.</p> <p>IBD is thought to be caused by a combination of genetic and environmental factors that alter gut homestasis and trigger immune-mediated inflammation. In particular, IBD is associated with an alteration of the composition of gut microbiota (\"dysbiosis\"), though the exact impact of the microbial community is still under investigation.</p> <p>Here, we will compare metagenome samples from patients with Inflammatory bowel disease (IBD) to samples from patients without IBD. We will characterize the microbial community associated with IBD vs non-IBD and assess the results in the context of current community findings for IBD</p>"},{"location":"06.download-assess-ibd-data/#background-reading","title":"Background Reading","text":"<p>Here are some articles that contain good background info on the human microbiome and IBD.</p> <ul> <li>The human microbiome in evolution</li> <li>Host\u2013microbiota interactions in inflammatory bowel disease</li> <li>Microbial genes and pathways in inflammatory bowel disease</li> </ul>"},{"location":"06.download-assess-ibd-data/#using-farm-for-downloads-and-analysis","title":"Using FARM for downloads and analysis:","text":"<p>Follow the instructions on Starting a Work Session on FARM to start a <code>tmux</code> session, get access to a compute node (via an <code>srun</code> interactive session).</p>"},{"location":"06.download-assess-ibd-data/#download-the-data","title":"Download the data","text":"<p>Now that we have a computer, let's download the data.</p> <p>note that you can also run these steps (and most analyses) on your personal computer</p> <ol> <li>Make a project directory</li> </ol> <pre><code>cd\nmkdir -p 2020-NSURP/raw_data\n</code></pre> <ol> <li>download samples to <code>raw_data</code> directory</li> </ol> <pre><code>cd 2020-NSURP/raw_data\n</code></pre> <p>Now, download two files for each of the following sample accession numbers using <code>wget</code>:</p> <pre><code># patient with Crohns disease\nwget https://ibdmdb.org/tunnel/static/HMP2/WGS/1818/CSM7KOJO.tar\nwget https://ibdmdb.org/tunnel/static/HMP2/WGS/1818/CSM7KOJG.tar\nwget https://ibdmdb.org/tunnel/static/HMP2/WGS/1818/CSM7KOJE.tar\n\n# patient with no IBD\nwget https://ibdmdb.org/tunnel/static/HMP2/WGS/1818/HSM5MD5B.tar\nwget https://ibdmdb.org/tunnel/static/HMP2/WGS/1818/HSM5MD5D.tar\nwget https://ibdmdb.org/tunnel/static/HMP2/WGS/1818/HSM6XRSX.tar\n</code></pre> <p>if you do <code>ls</code> now, you should see the following:</p> <pre><code>CSM7KOJE.tar  CSM7KOJO.tar  HSM5MD5D.tar\nCSM7KOJG.tar  HSM5MD5B.tar  HSM6XRSX.tar\n</code></pre> <p>Untar each set of files:</p> <pre><code>tar xf CSM7KOJO.tar\n</code></pre> <p>Now, let's make the files difficult to modify or delete:</p> <pre><code>chmod u-w *fastq.gz\n</code></pre>"},{"location":"06.download-assess-ibd-data/#fastq-format","title":"FASTQ format","text":"<p>Although it looks complicated (and it is), we can understand the fastq format with a little decoding. Some rules about the format include...</p> Line Description 1 Always begins with '@' and then information about the read 2 The actual DNA sequence 3 Always begins with a '+' and sometimes the same info in line 1 4 Has a string of characters which represent the quality scores; must have same number of characters as line 2 <p>We can view the first complete read in a fastq file by using <code>head</code> to look at the first four lines. Because the our files are gzipped, we first temporarily decompress them with <code>zcat</code>.</p> <pre><code>zcat CSM7KOJE_R1.fastq.gz | head -n 4\n</code></pre> <p>The first four lines of the file look something like this:</p> <p>Note: this is a different dataset, so your will look slightly different, though the formatting is the same</p> <pre><code>@SRR2584863.1 HWI-ST957:244:H73TDADXX:1:1101:4712:2181/1\nTTCACATCC@CAYNHANXX170426:3:1101:10002:54478/1\nATCCTTTACAATTACAAGATGCGTATGACCGCCTGATACAACAAGACATAAGAACGGAGGTTCCAGCTCTAAGTTTTCTATATAATTGGCAGAAATATG\n+\nB&lt;BBBFFFFFFFFFFFFFFFFFBFFFFFFFFFFF&lt;BFBFFFFFFF&lt;FFFFFBFFFF/&lt;F/BFF&lt;&lt;BFFBFFFFFFF&lt;F&lt;&lt;/FF/FFFFBFF&lt;/&lt;FB7FFTGACCATTCAGTTGAGCAAAATAGTTCTTCAGTGCCTGTTTAACCGAGTCACGCAGGGGTTTTTGGGTTACCTGATCCTGAGAGTTAACGGTAGAAACGGTCAGTACGTCAGAATTTACGCGTTGTTCGAACATAGTTCTG\n+\nCCCFFFFFGHHHHJIJJJJIJJJIIJJJJIIIJJGFIIIJEDDFEGGJIFHHJIJJDECCGGEGIIJFHFFFACD:BBBDDACCCCAA@@CA@C&gt;C3&gt;@5(8&amp;&gt;C:9?8+89&lt;4(:83825C(:A#########################\n</code></pre> <p>Line 4 shows the quality for each nucleotide in the read. Quality is interpreted as the probability of an incorrect base call (e.g. 1 in 10) or, equivalently, the base call accuracy (e.g. 90%). To make it possible to line up each individual nucleotide with its quality score, the numerical score is converted into a code where each individual character represents the numerical quality score for an individual nucleotide. 'For example, in the line above, the quality score line is:</p> <pre><code>CCCFFFFFGHHHHJIJJJJIJJJIIJJJJIIIJJGFIIIJEDDFEGGJIFHHJIJJDECCGGEGIIJFHFFFACD:BBBDDACCCCAA@@CA@C&gt;C3&gt;@5(8&amp;&gt;C:9?8+89&lt;4(:83825C(:A#########################\n</code></pre> <p>The numerical value assigned to each of these characters depends on the  sequencing platform that generated the reads. The sequencing machine used to generate our data  uses the standard Sanger quality PHRED score encoding, using Illumina version 1.8 onwards. Each character is assigned a quality score between 0 and 41 as shown in the chart below.</p> <pre><code>Quality encoding: !\"#$%&amp;'()*+,-./0123456789:;&lt;=&gt;?@ABCDEFGHIJ\n                   |         |         |         |         |\nQuality score:    01........11........21........31........41\n</code></pre> <p>Each quality score represents the probability that the corresponding nucleotide call is incorrect. This quality score is logarithmically based, so a quality score of 10 reflects a base call accuracy of 90%, but a quality score of 20 reflects a base call accuracy of 99%. These probability values are the results from the base calling algorithm and depend on how much signal was captured for the base incorporation.</p> <p>Looking back at our example read:</p> <pre><code>@SRR2584863.1 HWI-ST957:244:H73TDADXX:1:1101:4712:2181/1\nTTCACATCCTGACCATTCAGTTGAGCAAAATAGTTCTTCAGTGCCTGTTTAACCGAGTCACGCAGGGGTTTTTGGGTTACCTGATCCTGAGAGTTAACGGTAGAAACGGTCAGTACGTCAGAATTTACGCGTTGTTCGAACATAGTTCTG\n+\nCCCFFFFFGHHHHJIJJJJIJJJIIJJJJIIIJJGFIIIJEDDFEGGJIFHHJIJJDECCGGEGIIJFHFFFACD:BBBDDACCCCAA@@CA@C&gt;C3&gt;@5(8&amp;&gt;C:9?8+89&lt;4(:83825C(:A#########################\n</code></pre> <p>we can now see that there is a range of quality scores, but that the end of the sequence is very poor (<code>#</code> = a quality score of 2). How does the first read in <code>SRR1211680_1.fastq.gz</code> compare to this example?</p>"},{"location":"06.download-assess-ibd-data/#assessing-quality-with-fastqc","title":"Assessing Quality with FastQC","text":"<p>For the most part, you won't be assessing the quality of all your reads by visually inspecting your FASTQ files. Rather, you'll be using a software program to assess read quality and filter out poor quality reads. We'll first use a program called FastQC to visualize the quality of our reads.</p> <p>FastQC has a number of features which can give you a quick impression of any problems your data may have, so you can take these issues into consideration before moving forward with your analyses. Rather than looking at quality scores for each individual read, FastQC looks at quality collectively across all reads within a sample. The image below shows one FastQC-generated plot that indicatesa very high quality sample:</p> <p></p> <p>The x-axis displays the base position in the read, and the y-axis shows quality scores. In this example, the sample contains reads that are 40 bp long. This is much shorter than the reads we are working with in our workflow. For each position, there is a box-and-whisker plot showing the distribution of quality scores for all reads at that position. The horizontal red line indicates the median quality score and the yellow box shows the 1st to 3rd quartile range. This means that 50% of reads have a quality score that falls within the range of the yellow box at that position. The whiskers show the absolute range, which covers the lowest (0th quartile) to highest (4th quartile) values.</p> <p>For each position in this sample, the quality values do not drop much lower than 32. This is a high quality score. The plot background is also color-coded to identify good (green), acceptable (yellow), and bad (red) quality scores.</p> <p>Now let's take a look at a quality plot on the other end of the spectrum.</p> <p></p> <p>Here, we see positions within the read in which the boxes span a much wider range. Also, quality scores drop quite low into the \"bad\" range, particularly on the tail end of the reads. The FastQC tool produces several other diagnostic plots to assess sample quality, in addition to the one plotted above.</p>"},{"location":"06.download-assess-ibd-data/#running-fastqc","title":"Running FastQC","text":"<p>We will now assess the quality of the reads that we downloaded. First, make sure you're still in the <code>raw_data</code> directory</p> <pre><code>cd ~/2020-NSURP/raw_data\n</code></pre> <p>Next, activate the conda environment we created in the Install Conda lesson.</p> <pre><code>conda activate nsurp-env\n</code></pre> <p>Now, use conda to install fastqc.</p> <pre><code>conda install fastqc\n</code></pre> <p>FastQC can accept multiple file names as input, and on both zipped and unzipped files, so we can use the *.fastq* wildcard to run FastQC on all of the FASTQ files in this directory.</p> <pre><code>fastqc *.fastq*\n</code></pre> <p>The FastQC program has created several new files within our directory. For each input FASTQ file, FastQC has created a <code>.zip</code> file and a <code>.html</code> file. The <code>.zip</code> file extension indicates that this is actually a compressed set of multiple output files. We'll be working with these output files soon. The <code>.html</code> file is a stable webpage displaying the summary report for each of our samples.</p>"},{"location":"06.download-assess-ibd-data/#transferring-data-from-farm-to-your-computer","title":"Transferring data from Farm to your computer","text":"<p>To transfer a file from a remote server to our own machines, we will use <code>scp</code>. To learn more about <code>scp</code>, see the bottom of this tutorial.</p> <p>Now we can transfer our HTML files to our local computer using <code>scp</code>. The <code>./</code> indicates that you're transferring files to the directory you're currently working from.</p> <pre><code>scp -P 2022  -i /path/to/key/file username@farm.cse.ucdavis.edu:~/2020-NSURP/raw_data/*.html ./\n</code></pre> <p>If you're on a mac using <code>zsh</code>, you may need to replace the <code>scp</code> with <code>noglob scp</code> in the command above. If you're on windows, you may need to move the the files from the download location on your Linux shell over to the windows side of your computer before opening.</p> <p>Once the file is on your local computer, double click on it and it will open in your browser. You can now explore the FastQC output.</p>"},{"location":"06.download-assess-ibd-data/#decoding-the-fastqc-output","title":"Decoding the FastQC Output","text":"<p>We've now looked at quite a few \"Per base sequence quality\" FastQC graphs, but there are nine other graphs that we haven't talked about! Below we have provided a brief overview of interpretations for each of these plots. For more information, please see the FastQC documentation here</p> <ul> <li>Per tile sequence quality: the machines that perform sequencing are divided into tiles. This plot displays patterns in base quality along these tiles. Consistently low scores are often found around the edges, but hot spots can also occur in the middle if an air bubble was introduced at some point during the run.</li> <li>Per sequence quality scores: a density plot of quality for all reads at all positions. This plot shows what quality scores are most common.</li> <li>Per base sequence content: plots the proportion of each base position over all of the reads. Typically, we expect to see each base roughly 25% of the time at each position, but this often fails at the beginning or end of the read due to quality or adapter content.</li> <li>Per sequence GC content: a density plot of average GC content in each of the reads.</li> <li>Per base N content: the percent of times that 'N' occurs at a position in all reads. If there is an increase at a particular position, this might indicate that something went wrong during sequencing.</li> <li>Sequence Length Distribution: the distribution of sequence lengths of all reads in the file. If the data is raw, there is often on sharp peak, however if the reads have been trimmed, there may be a distribution of shorter lengths.</li> <li>Sequence Duplication Levels: A distribution of duplicated sequences. In sequencing, we expect most reads to only occur once. If some sequences are occurring more than once, it might indicate enrichment bias (e.g. from PCR). If the samples are high coverage (or RNA-seq or amplicon), this might not be true.</li> <li>Overrepresented sequences: A list of sequences that occur more frequently than would be expected by chance.</li> <li>Adapter Content: a graph indicating where adapater sequences occur in the reads.</li> <li>K-mer Content: a graph showing any sequences which may show a positional bias within the reads.</li> </ul>"},{"location":"06.download-assess-ibd-data/#extra-info","title":"Extra Info","text":"<p>if you ever need to download &gt;10 accessions from the SRA, the <code>sra-toolkit</code> is a great tool to do this with! However, we find <code>sra-toolkit</code> cumbersome when only a couple accessions need to be downloaded.</p>"},{"location":"07.quality-control/","title":"Quality Control the Data","text":"<p>If you're starting a new work session on FARM, be sure to follow the instructions here.</p> <p>After downloading sequencing data, the next step in many pipelines is to perform quality control trimming on the reads. However, deciding when and how to trim data is pipeline dependent. Below, we define a few types of quality control and explore a use cases and how trimming recommendations may change with different applications. Although this project focuses on metagenomic sequencing, we include other applications in this discussion.</p>"},{"location":"07.quality-control/#types-of-quality-control","title":"Types of Quality Control","text":"<ul> <li>Adapter and barcode trimming: Adapter sequences are added to a sample library to aid in the physical process of sequencing. They are ubiquitous within a certain chemistry, and so are present across all sequenced samples.  Barcodes are unique nucleotide sequences used to identify a specific sample when multiple samples are sequenced in a single lane. After barcoded samples are separated from one another in a process called demultiplexing, barcodes are no longer needed in a sequence.  It is generally a good idea to remove adapters and barcodes from sequencing samples before proceeding with any downstream application.  However, if you are using a pipeline that involves matching between reads and a quality reference, you may get similar results with or without adapter trimming. For quick estimation </li> <li>Quality trimming: Quality trimming removes low-quality bases from sequences reads. The user can set the stringency cut off for \"low quality\" by indicating a phred score at which to trim. </li> <li>K-mer trimming: K-mer trimming removes k-mers that occur very few times in a sequencing dataset. In reads with sufficient sequencing depth, we expect real k-mers to occur multiple times. When a single sequencing error occurs in a read, this produces k erroneous k-mers. K-mer trimming trims a read to remove all of these k-mers. K-mer trimming does not rely on information from the sequencer like phred scores, but instead on the biological signal in the reads themselves.</li> </ul>"},{"location":"07.quality-control/#when-and-how-to-trim","title":"When and how to trim?","text":"<p>Trimming is a balance of removing artificial or incorrect nucleotides and retaining true nucleotides in sequencing data.  What and when to trim therefore changes with the sequencing application, and with the sequencing data itself.  Below we explore some trimming use cases to help develop an intuition for what type of trimming is necessary and when.</p> <ul> <li>Single-species genomic sequencing for assembly:  Let's imagine we have just sequenced an Escherichia coli isolate with 100X coverage and would like to assemble the isolate.  We would first want to remove adapters and barcodes to prevent these sequences from ending up in our final assembly.  Then, stringent quality and k-mer trimming may be appropriate, because we have high coverage data; even if we were to stringently trim and were only left with 50% of our original number of reads, we would still have 50X coverage of very high quality data.  50X coverage is sufficient to acheive a good bacterial assembly in most cases. </li> <li>de novo RNA-sequencing assembly Now let's imagine we have sequenced the transcriptome of our favorite species which does not currently have a reference transcriptome. Because RNA transcripts have different abundance profiles, we can't use average coverage in the same way as we used it for single-species genomic sequencing.  We need to be more careful when we k-mer and error trim so as not to accidentally remove low-abundance reads that represent true transcripts. We would likely use light quality trimming (e.g. a phred score of ~5). For k-mer trimming, we would only trim reads that contain high-abundance k-mers.</li> <li>Metagenome de novo assembly Trimming metagenomic reads for de novo assembly is similar to trimming RNA-sequencing reads for de novo transcriptome assembly. Because there are often low-abundance organisms that have low-coverage in our sequencing datasets, we need to be careful not to accidently remove these during trimming. </li> <li>Metagenome read mapping  In referenced-based analyses including mapping of metagenomic reads to a set of reference genomes, reads will often map even when they contain adapters and barcodes.  However, in some cases, the presence of adapters and barcodes does prevent mapping, so it is safer to remove all barcodes and adapters. </li> </ul>"},{"location":"07.quality-control/#references-about-trimming","title":"References about trimming","text":"<p>Many scientific studies have explored the trimming parameter space in an effort to make recommendations for different applications.  We include some of these studies below.</p> <ul> <li>On the optimal trimming of high-throughput mRNA sequence data</li> <li>An Extensive Evaluation of Read Trimming Effects on Illumina NGS Data Analysis</li> </ul>"},{"location":"07.quality-control/#quality-and-adapter-trimming-with-fastp","title":"Quality and Adapter trimming with Fastp","text":"<p>We will use fastp to do quality trimming of our reads.</p> <p>In the Download and Visual Assessment Module, we saw using FastQC that the Illumina Universal Adapter was present in our samples.</p> <p></p> <p>We also saw that the sequence read quality dropped dramatically toward the end of the read.</p> <p></p> <p>We will remove both of these sequences using fastp. Fastp also creates its own FastQC-style <code>html</code> reports for the files that we can look at after running.</p>"},{"location":"07.quality-control/#run-fastp","title":"Run fastp","text":"<p>Reminder, make sure you've followed the Starting a Work Session steps to get your Farm session set up. You should be within your <code>nsurp-env</code> conda environment.</p> <p>Install fastp:</p> <pre><code>conda install -y fastp\n</code></pre> <p>We can now trim our data! Let's set up our directory structure:</p> <pre><code>cd ~/2020-NSURP\nmkdir -p trim\ncd trim\n</code></pre> <p>Run fastp on the <code>CSM7KOJE</code> sample with the following command:</p> <pre><code>fastp --in1 ~/2020-NSURP/raw_data/CSM7KOJE_R1.fastq.gz \\\n  --in2 ~/2020-NSURP/raw_data/CSM7KOJE_R2.fastq.gz \\\n  --out1 CSM7KOJE_1.trim.fastq.gz \\\n  --out2 CSM7KOJE_2.trim.fastq.gz \\\n  --detect_adapter_for_pe \\\n  --qualified_quality_phred 4 \\\n  --length_required 31 --correction \\\n  --json CSM7KOJE.trim.json \\\n  --html CSM7KOJE.trim.html\n</code></pre> <p>Command Breakdown</p> <ul> <li><code>--in1</code>, <code>--in2</code> - the read1 and read2 input file names</li> <li><code>--out1</code>, <code>--out2</code> - the read1 and read2 output file names</li> <li><code>--detect_adapter_for_pe</code> - Auto detect the adapters for our paired end (PE) reads, and remove them during trimming</li> <li><code>--length_required</code> - discard reads shorter than <code>length_required</code> paramter (default is 15)</li> <li><code>--correction</code> - enable base correction if the paired end reads overlap (only for PE data),</li> <li><code>--qualified_quality_phred</code> - the quality value that a base is qualified. Default 15 means phred quality &gt;=Q15 is qualified. (int [=15])</li> <li><code>--html</code>, <code>--json</code> - file name for the fastp trimming report printed to html and/or json format </li> </ul> <p>We change the Phred quality score cutoff to <code>4</code> to be more lenient in our trimming. Recall from our FastQC lesson that a quality score of 10 indicates a 1 in 10 chance that the base is inaccurate.  A score of 20 is a 1 in 100 chance that the base is inaccurate. 30 is 1 in 1,000. And 40 in 1 in 10,000.  By using a score of 4, we are more likely to keep data that has a high probability of being accurate. </p> <p>As done in downloading sequencing data, you can use <code>scp</code> to copy the html report to your computer:</p> <pre><code>scp -P 2022  -i /path/to/key/file username@farm.cse.ucdavis.edu:~/2020-NSURP/trim/*.html ./\n</code></pre> <p>If you're on a mac using <code>zsh</code>, you may need to replace the <code>scp</code> with <code>noglob scp</code> in the command above.</p> <p>If you're on windows, you may need to move the the files from the download location on your Linux shell over to the windows side of your computer before opening.</p> <p>Once the file is on your local computer, double click on it and it will open in your browser. You can now explore the fastp trimming report.</p>"},{"location":"07.quality-control/#why-or-why-not-do-k-mer-trimming","title":"Why (or why not) do k-mer trimming?","text":"<p>Even after quality trimming with fastp, our reads will still contain errors. Why?</p> <p>First, fastp trims based solely on the quality score, which is a statistical statement about the correctness of a base - a Q score of 30 means that, of 1000 bases with that Q score, 1 of those bases will be wrong. So, a base can have a high Q score and still be wrong (and many bases will have a low Q score and still be correct)!</p> <p>Second, we trimmed very lightly - only bases that had a very low quality were removed. This was intentional because we want to retain as much coverage as possible for our downstream techniques (many of which do not suffer too much if some errors remain).</p> <p>An alternative to trimming based on the quality scores is to trim based on k-mer abundance - this is known as k-mer spectral error trimming. K-mer spectral error trimming always beats quality score trimming in terms of eliminating errors; e.g. look at this table from Zhang et al., 2014:</p> <p></p> <p>The basic logic is this: if you see low abundance k-mers in a high coverage data set, those k-mers are almost certainly the result of errors. (Caveat: strain variation could also create them.)</p> <p>In metatranscriptomic data sets we do have the problem that we may have very low and very high coverage data. So we don\u2019t necessarily want to get rid of all low-abundance k-mers, because they may represent truly low abundance (but useful) data.</p> <p>As part of the khmer project in our lab, we have developed an approach that sorts reads into high abundance and low abundance reads, and only error trims the high abundance reads.</p> <p></p> <p>This does mean that many errors may get left in the data set, because we have no way of figuring out if they are errors or simply low coverage, but that\u2019s OK (and you can always trim them off if you really care).</p>"},{"location":"07.quality-control/#kmer-trimming-with-khmer","title":"Kmer trimming with khmer","text":"<p>Next, let's k-mer trim our data.  This will take 20GB of RAM and a few hours to complete.  We didn't ask for quite that much RAM when we initially got our computer, so we'll need a different one.</p> <p>First, exit your current <code>srun</code> session</p> <pre><code>exit\n</code></pre> <p>Next, use this <code>srun</code> command to get a larger computer that can handle the k-mer trimming analysis:</p> <pre><code>srun -p bmh -J khmer -t 20:00:00 --mem=21gb -c 1 --pty bash\n</code></pre> <p>Since we changed computers, our conda environment was automatically deactivated.</p> <p>Activate your project environment again:</p> <pre><code>conda activate nsurp-env\n</code></pre>"},{"location":"07.quality-control/#install-khmer","title":"Install khmer","text":"<p>We need to install the software we will use to perform k-mer trimming, <code>khmer</code>. Make sure you activate the conda environment you are using for this project with <code>conda activate env_name</code>.</p> <pre><code>conda install -y khmer\n</code></pre>"},{"location":"07.quality-control/#using-khmer-for-k-mer-trimming","title":"Using khmer for k-mer trimming","text":"<p>Once <code>khmer</code> is installed, we can use it for k-mer trimming.  Let's get our files and directories set up:</p> <pre><code>cd ~/2020-NSURP\nmkdir -p kmer-trim\ncd kmer-trim\n</code></pre> <p>Now we can run k-mer trimming! The first line of this command interleaves our paired end reads, putting them in one file where forward and reverse reads alternate on each line. The second line of this command performs the k-mer trimming. </p> <p>Note that these commands are connected by the pipe (<code>|</code>) character. This character means that the first half of the command (before the <code>|</code>) is executed first, and the output is passed (\"piped\") to the second half of the command (after the <code>|</code>).</p> <pre><code>interleave-reads.py ~/2020-NSURP/trim/CSM7KOJE_1.trim.fastq.gz ~/2020-NSURP/trim/CSM7KOJE_2.trim.fastq.gz | \\\n        trim-low-abund.py --gzip -C 3 -Z 18 -M 20e9 -V - -o CSM7KOJE.kmertrim.fq.gz\n</code></pre> <p>Note: Here, we are referencing the trimmed files using an absolute path: <code>~/2020-NSURP/trim/</code>. That is, to access these files, we go to our home directory (<code>~</code>), then descend into the <code>2020-NSURP</code> folder, then descend again into the <code>trim</code> folder.</p>"},{"location":"07.quality-control/#assess-changes-in-kmer-abundance","title":"Assess changes in kmer abundance","text":"<p>To see how many k-mers we removed, you can examine the distribution as above, or use the <code>unique-kmers.py</code> script. Let's compare kmers for one sample.</p> <pre><code>unique-kmers.py ../trim/CSM7KOJE_1.trim.fastq.gz ../trim/CSM7KOJE_2.trim.fastq.gz\nunique-kmers.py CSM7KOJE.kmertrim.fq.gz\n</code></pre> <p>Note, here we are using a relative path, <code>../trim/</code>. That is, to access the <code>CSM7KOJE_*.trim.fastq.gz</code> files, we go up one directory (<code>../</code>), then down into <code>trim</code>.</p> <p>The raw adapter-trimmed inputs have an estimated 164426731 unique 32-mers.</p> <pre><code>Estimated number of unique 32-mers in ../trim/CSM7KOJE_1.trim.fastq.gz: 83127191\nEstimated number of unique 32-mers in ../trim/CSM7KOJE_2.trim.fastq.gz: 80110484\nTotal estimated number of unique 32-mers: 98077936\n</code></pre> <p>The k-mer trimmed file (kmer output) has an estimated 163890994 unique 32-mers.</p> <pre><code>Estimated number of unique 32-mers in CSM7KOJE.kmertrim.fq.gz: 163890994\nTotal estimated number of unique 32-mers: 163890994\n</code></pre> <p>Note that the second number is smaller than the first, with a little over 500,000 low-abundance k-mers having been removed as likely errors. These are pretty small sample datasets that are already relatively clean - often the difference in unique k-mers is MUCH larger!</p>"},{"location":"07.quality-control/#challenge-quality-control","title":"Challenge: quality control","text":"<p>Make sure you do <code>fastp</code> and <code>khmer</code> trimming on each of the 6 datasets. Keep track of the commands you use in a HackMD lab notebook. Use backticks to create code blocks and be sure to write notes describing the purpose of each step and any problems you encountered. There's no need to count unique k-mers for every dataset, but feel free if you'd like to look at the differences :).</p>"},{"location":"08.taxonomic-discovery-with-sourmash/","title":"Taxonomic Discovery with Sourmash","text":"<p>Until now, we've performed general pre-processing steps on our sequencing data; sequence quality analysis and trimming usually occur at the start of any sequencing data analysis pipeline. Now we will begin performing analysis that makes sense for metagenomic sequencing data. </p> <p>We are working with publicly-available data, but let's pretend that this is a brand new sample that we just got back from our sequencing core.  One of the first things we often want to do with new metagenome sequencing samples is figure out their approximate species composition.  This allows us to tap in to all of the information known about these species and relate our community to existing literature. </p> <p>We can determine the approximate composition of our sample using <code>sourmash</code>. </p>"},{"location":"08.taxonomic-discovery-with-sourmash/#introduction-to-sourmash","title":"Introduction to sourmash","text":"<p>Please read this tutorial for an introduction to how sourmash works. </p> <p>tl;dr (but actually please read it): sourmash breaks nucleotide sequences down into k-mers, systematically subsamples those k-mers into a representative \"signature\", and then enables searches for those k-mers in databases. This makes it really fast to make comparisons. Here, we will compare our metagenome sample against a pre-prepared database that contains all microbial sequences in GenBank.</p>"},{"location":"08.taxonomic-discovery-with-sourmash/#workspace-setup","title":"Workspace Setup","text":"<p>If you're starting a new work session on FARM, be sure to follow the instructions here. You can just do the part to enter a <code>tmux</code> session, since we'll be using a larger <code>srun</code> session than usual.</p>"},{"location":"08.taxonomic-discovery-with-sourmash/#starting-with-sourmash","title":"Starting with sourmash","text":"<p>Sourmash doesn't have a big memory or CPU footprint, and can be run on most laptops.  Below is a recommended <code>srun</code> command to start an interactive session in which to run the <code>srun</code> commands.</p> <pre><code>srun -p bmh -J sourmash24 -t 24:00:00 --mem=16gb -c 1 --pty bash\n</code></pre>"},{"location":"08.taxonomic-discovery-with-sourmash/#install-sourmash","title":"Install sourmash","text":"<p>Be sure you've set up conda channels properly, as in the Install Conda section</p> <pre><code>conda activate nsurp-env\nconda install -y sourmash\n</code></pre> <p>Next, let's create a directory in which to store our sourmash signatures</p> <pre><code>cd ~/2020-NSURP\nmkdir -p sourmash\ncd sourmash\n</code></pre>"},{"location":"08.taxonomic-discovery-with-sourmash/#what-data-to-use","title":"What data to use?","text":"<p>We could run sourmash with our adapter trimmed or k-mer trimmed data. In fact, doing so would make sourmash faster because there would be fewer k-mers in the sample.</p> <p>We are currently comparing our sample against a database of trusted DNA sequences, so any k-mers in our sample that contain adapters sequence or errors will not match to the trusted reference sequences in the database. However, even though we very lightly trimmed our reads, there is a chance that we removed a very low abundance organism that was truly present in the sample. Given this trade-off, we use often raw reads for reference data comparisons, and quality-controlled reads for all other comparisons.</p>"},{"location":"08.taxonomic-discovery-with-sourmash/#generate-a-sourmash-signature","title":"Generate a sourmash signature","text":"<p>Next, let's make sourmash signatures from our reads.</p> <p>Remember from the Quick Insights from Sequencing Data with sourmash tutorial that a k-mer size of 21 is approximately specific at the genus level, a 31 is at the species level, and 51 at the strain level. We will calculate our signature with all three k-mer sizes so we can choose which one we want to use later.</p> <pre><code>sourmash compute -o CSM7KOJE.raw.sig --merge CSM7KOJE --scaled 2000 -k 21,31,51 --track-abundance ~/2020-NSURP/raw_data/CSM7KOJE_*fastq.gz\n</code></pre> <p>You should see output that looks like this:</p> <pre><code>== This is sourmash version 3.4.1. ==\n== Please cite Brown and Irber (2016), doi:10.21105/joss.00027. ==\n\nsetting num_hashes to 0 because --scaled is set\ncomputing signatures for files: /home/ntpierce/2020-NSURP/raw_data/CSM7KOJE_R1.fastq.gz, /home/ntpierce/2020-NSURP/raw_data/CSM7KOJE_R2.fastq.gz\nComputing signature for ksizes: [21, 31, 51]\nComputing only nucleotide (and not protein) signatures.\nComputing a total of 3 signature(s).\nTracking abundance of input k-mers.\n... reading sequences from /home/ntpierce/2020-NSURP/raw_data/CSM7KOJE_R1.fastq.gz\n... /home/ntpierce/2020-NSURP/raw_data/CSM7KOJE_R1.fastq.gz 9704045 sequences\n... reading sequences from /home/ntpierce/2020-NSURP/raw_data/CSM7KOJE_R2.fastq.gz\n... /home/ntpierce/2020-NSURP/raw_data/CSM7KOJE_R2.fastq.gz 9704045 sequences\ncalculated 1 signatures for 19408090 sequences taken from 2 files\nsaved signature(s) to CSM7KOJE.raw.sig. Note: signature license is CC0.\n</code></pre> <p>The outputs file, <code>CSM7KOJE.raw.sig</code> holds a representative subset of k-mers from our original sample, as well as their abundance information.  The k-mers are \"hashed\", or transformed, into numbers to make selecting, storing, and looking up the k-mers more efficient.</p>"},{"location":"08.taxonomic-discovery-with-sourmash/#sourmash-gather","title":"Sourmash gather","text":"<p><code>sourmash gather</code> is a method for estimating the taxonomic composition of known sequences in a metagenome.</p> <p>Please go read through the sourmash documentation on Breaking down metagenomic samples with gather and lca. Check out Appendix A and B in this documentation for a good overview of how sourmash gather works.</p> <p>Running gather on our IBD samples can give us an idea of the microbes present in each sample.  <code>gather</code> results provide strain-level specificity to matches in its output -- e.g. all strains that match any sequences (above a threshold) in your metagenome will be reported, along with the percent of each strain that matches.  This is useful both to estimate the amount of metagenome sample that is known, and to estimate the closest strain relative to the organisms in your metagenomes.</p>"},{"location":"08.taxonomic-discovery-with-sourmash/#download-and-unzip-the-database","title":"Download and unzip the database:","text":"<pre><code>mkdir -p ~/2020-NSURP/databases/\ncd ~/2020-NSURP/databases/\ncurl -L https://osf.io/jgu93/download -o genbank-k31.sbt.zip\ncd ~/2020-NSURP/sourmash\n</code></pre>"},{"location":"08.taxonomic-discovery-with-sourmash/#run-sourmash-gather","title":"Run sourmash gather","text":"<p>First, let's run a very quick search:</p> <pre><code>sourmash gather --num-results 10 CSM7KOJE.raw.sig ~/2020-NSURP/databases/genbank-k31.sbt.zip\n</code></pre> <ul> <li>the <code>--num-results 10</code> is a way of shortening the search. In this case, we ask for only the top 10 results</li> </ul> <p>We see an output that looks like this:</p> <pre><code>== This is sourmash version 3.4.1. ==\n== Please cite Brown and Irber (2016), doi:10.21105/joss.00027. ==\n\nselecting default query k=31.\nloaded query: CSM7KOJE... (k=31, DNA)\nloaded 1 databases.\n\n\noverlap     p_query p_match avg_abund\n---------   ------- ------- ---------\n6.4 Mbp        9.5%   63.6%      17.4    CBWF010000001.1 Klebsiella pneumoniae...\n5.3 Mbp       25.6%   90.6%      56.5    KB851045.1 Clostridium clostridioform...\n5.1 Mbp        3.6%   74.4%       8.5    GG668320.1 Clostridium hathewayi DSM ...\n4.4 Mbp        2.0%   83.9%       5.4    LBDB01000001.1 Vibrio parahaemolyticu...\n3.2 Mbp        5.0%   80.5%      18.6    JTBP01000001.1 Proteus mirabilis stra...\n4.8 Mbp        1.0%   33.6%       4.2    JRSL01000930.1 Escherichia coli strai...\n2.7 Mbp        0.8%   59.5%       3.5    FUNQ01000052.1 Clostridioides diffici...\n2.5 Mbp        3.5%   33.9%      16.3    CZAT01000001.1 Flavonifractor plautii...\n4.9 Mbp        2.3%   45.1%      11.7    KQ087951.1 Escherichia coli strain BI...\n2.2 Mbp        3.3%   64.6%      18.1    FCEY01000001.1 Clostridium sp. AT5 ge...\n\nfound 10 matches total;\n(truncated gather because --num-results=10)\nthe recovered matches hit 56.8% of the query\n</code></pre> <p>The shortened search will be quite quick. </p> <p>The two columns to pay attention to are <code>p_query</code> and <code>p_match</code>. <code>p_query</code> is the percent of the metagenome sample that is (estimated to be) from the named organism.  <code>p_match</code> is the percent of the database match that is found in the query. These metrics` are affected by both evolutionary distance and by low coverage of the organism's gene set (low sequencing coverage, or little expression).</p> <p>Now, let's run the full <code>gather</code> analysis: This will take a long time to run. Sourmash will also output a csv with all the results information that we will use later to visualize our results.</p> <pre><code>sourmash gather -o CSM7KOJE_x_genbank-k31.gather.csv CSM7KOJE.raw.sig ~/2020-NSURP/databases/genbank-k31.sbt.zip\n</code></pre> <p>When sourmash is finished running, it tells us the % of our sequence was unclassified; i.e. it doesn't match any sequence in the database.</p> <p>In a later module, we may use additional steps prior to <code>gather</code> to improve the percent of sequence in the metagenome that is classifiable. These include, for example, using <code>bbduk</code> to remove additional human genome k-mers or using assembly-style programs such as <code>megahit</code> or spacegraphcats, to build longer contiguous gene sequences.</p>"},{"location":"08.taxonomic-discovery-with-sourmash/#other-methods-for-taxonomic-discovery-and-classification","title":"Other Methods for Taxonomic Discovery and Classification","text":"<p>There are many tools, such as Kraken and Kaiju, that can do taxonomic classification of individual reads from metagenomes. These seem to perform well (albeit with high false positive rates) in situations where you don\u2019t necessarily have the genome sequences that are in the metagenome.  Sourmash, by contrast, can estimate which known genomes are actually present, so that you can extract them and map/align to them.  It seems to have a very low false positive rate and is quite sensitive to strains.</p>"},{"location":"08.taxonomic-discovery-with-sourmash/#detecting-contamination-or-incorrect-data","title":"Detecting contamination or incorrect data","text":"<p>sourmash <code>gather</code> taxonomic discovery can help uncover contamination or errors in your sequencing samples. We recommend doing sourmash gather immediately after receiving your data from the sequencing facility. If your environmental metagenome has a tremendous amount of mouse sequence in it... maybe the sequencing facility sent you the wrong data?</p>"},{"location":"08.taxonomic-discovery-with-sourmash/#challenge-sourmash-gather","title":"Challenge: sourmash gather","text":""},{"location":"08.taxonomic-discovery-with-sourmash/#gather-with-trimmed-data","title":"Gather with trimmed data","text":"<p>Above, we ran <code>sourmash gather</code> on our untrimmed data.  44% of the sample did not contain sequence in any GenBank assembly.  A substantial proportion of this sequence could be due to k-mers with errors. Run <code>sourmash gather</code> again on the adapter/ k-mer trimmed data. How much less of the sequence is unclassifiable when the errors and adapters are removed? How many species are no longer detected after k-mer and error trimming?</p>"},{"location":"08.taxonomic-discovery-with-sourmash/#gather-at-different-ksizes","title":"Gather at different ksizes","text":"<p>The genbank reference databases for signatures of ksize k=21 and k=51 are available for download.</p> <p>k=21</p> <pre><code>cd ~/2020-NSURP/databases/\ncurl -L https://osf.io/dm7n4/download -o genbank-k21.sbt.zip\n</code></pre> <p>k=51</p> <pre><code>cd ~/2020-NSURP/databases/\ncurl -L https://osf.io/2uvsc/download -o genbank-k51.sbt.zip\n</code></pre> <p>How do you expect the gather results to differ for each? Why?</p>"},{"location":"08.taxonomic-discovery-with-sourmash/#test-gather-parameters","title":"Test Gather parameters","text":"<p>By running <code>sourmash gather --help</code>, you can see all the options for the <code>gather</code> program.</p>"},{"location":"08.taxonomic-discovery-with-sourmash/#scaled","title":"scaled","text":"<p>The <code>scaled</code> option provides a chaces to downample the query to the specified scaled factor.</p> <pre><code>  --scaled FLOAT        downsample query to the specified scaled factor\n</code></pre> <p>Try running gather with a <code>scaled</code> value of 50000. How do the results change, and why?</p>"},{"location":"08.taxonomic-discovery-with-sourmash/#base-pair-threshold-for-matches","title":"base pair threshold for matches","text":"<p>The <code>threshold-bp</code> option lets you only find matches that have at least this many base pairs in common (default 50,000 bp)</p> <p>Increasing the threshold makes gather quicker (at the expense of losing some of the smaller matches):</p> <pre><code>--threshold-bp 10000000\n</code></pre> <p>What happens if you run gather with the threshold above?</p> <p>Decreasing the threshold will take more time, but be more thorough. A threshold of 0bp does an exhaustive search for all matches</p> <pre><code>--threshold-bp 0\n</code></pre> <p>The full gather took quite a long time on our samples, so there's no need to run this one! But do keep it in mind as a way to make sure we get absolutely all of the matches we can get using gather.</p>"},{"location":"09.comparing-samples-with-sourmash/","title":"Comparing Samples with Sourmash","text":"<p>Many metagenomics projects are designed to assess the differences between microorganism composition between samples. There are many ways to get at this question, but we can start by using k-mer profiles of the reads to quickly compare samples using <code>sourmash compare</code>.</p>"},{"location":"09.comparing-samples-with-sourmash/#workspace-setup","title":"Workspace Setup","text":"<p>If you're starting a new work session on FARM, be sure to follow the instructions here.</p> <p>First, let's make a directory that we will be working in:</p> <pre><code>cd ~/2020-NSURP\nmkdir -p sourmash-compare\ncd sourmash-compare\n</code></pre> <p>Note: we made a directory called <code>sourmash</code> for the taxonomic discovery module. It helps to name files and folders with details that will help you remember what results are contained therein. How could the prior module's folder name be changed to be more informative?</p>"},{"location":"09.comparing-samples-with-sourmash/#calculate-sourmash-signatures","title":"Calculate sourmash signatures","text":"<p>Now we can calculate signatures for each of the files. This will take 5 or 10 minutes to run</p> <pre><code>for infile in ~/2020-NSURP/kmer-trim/*.kmertrim.fq.gz\ndo\n    name=$(basename ${infile} .kmertrim.fq.gz)\n    echo $name\n    sourmash compute -k 21,31,51 --scaled 2000 --track-abundance --merge ${name} -o ${name}.kmertrim.sig ${infile}\ndone\n</code></pre> <p>Note: Here we used bash <code>for loop</code> to compute signatures on each file with a single set of commands. Go through this tutorial to learn about loops!</p>"},{"location":"09.comparing-samples-with-sourmash/#compare-sample-signatures","title":"Compare sample signatures","text":"<p>Using these signatures, we can compare our samples.</p> <pre><code>sourmash compare -k 31 -o IBD.kmertrim.compare.np --csv IBD.kmertrim.compare.csv --ignore-abundance *sig\n</code></pre> <p>Now let's plot! Sourmash has a built in plot utility that we can take advantage of. The output is a heatmap.</p>"},{"location":"09.comparing-samples-with-sourmash/#visualize-the-comparison-using-sourmash-plot","title":"Visualize the comparison using sourmash plot","text":"<pre><code>sourmash plot --labels IBD.kmertrim.compare.np\n</code></pre> <p>This command produces three <code>png</code> files:</p> <pre><code>IBD.kmertrim.compare.np.hist.png\nIBD.kmertrim.compare.np.dendro.png\nIBD.kmertrim.compare.np.matrix.png\n</code></pre> <p>As usual, these files can be downloaded to your local computer with <code>scp</code></p> <pre><code>scp -P 2022  -i /path/to/key/file username@farm.cse.ucdavis.edu:~/2020-NSURP/sourmash-compare/*.png ./\n</code></pre> <p>If you're on a mac using <code>zsh</code>, you may need to replace the <code>scp</code> with <code>noglob scp</code> in the command above.</p> <p>If you're on windows, you may need to move the the files from the download location on your Linux shell over to the windows side of your computer before opening.</p> <p>Once the files are on your local computer, double click to open each file.  The <code>.matrix.png</code> is the heatmap file, which will show the pattern of similarity between samples</p> <p>It should look like this:</p> <p>.</p> <p>What does this heatmap tell you about your samples? For example, does it provide any information about which samples are from IBD patients, and which are from non-IBD patients?</p>"},{"location":"09.comparing-samples-with-sourmash/#visualize-the-comparison-in-an-mds-plot","title":"Visualize the comparison in an MDS plot","text":"<p>We can use this output to make a Multidimensional Scaling plot. MDS plots are commonly used in visualize similarities and differences between samples. Here the strength is we used the k-mer content of all of our reads to calculate similarity.</p>"},{"location":"09.comparing-samples-with-sourmash/#install-the-r-packages-ggplot2-and-ggrepel","title":"Install the R packages ggplot2 and ggrepel","text":"<p>Since this is conda, it will recognize that it needs to install R alongside these, and take care of that for you! Usually you'll want to be careful of which version of R you're installing, but since we're just doing this one R command, we'll be a little lax about it.</p> <pre><code>conda install r-ggplot2 r-ggrepel \n</code></pre>"},{"location":"09.comparing-samples-with-sourmash/#download-an-r-script-to-make-the-mds-plot","title":"Download an R script to make the MDS plot","text":"<p>The script source is here if you are interested!</p> <pre><code>wget https://raw.githubusercontent.com/dib-lab/2020-NSURP/master/scripts/mds_plot.R\n</code></pre>"},{"location":"09.comparing-samples-with-sourmash/#run-the-r-script","title":"Run the R script","text":"<pre><code>Rscript mds_plot.R IBD.kmertrim.compare.csv IBD.kmertrim.compare.mds.pdf\n</code></pre> <p>This outputs a file <code>IBD.kmertrim.compare.mds.pdf</code>. You can see that file by downloading to your computer. It should look something like this:</p> <p>.</p> <p>How do the samples cluster? How does this compare to our heatmap, generated by <code>sourmash plot</code>, above?</p>"},{"location":"10.workflows-and-repeatability/","title":"Workflows, Automation, and Repeatability","text":"<p>For everything we have done so far, we have copied and pasted a lot of commands to accomplish what we want. This works! But can also be time consuming, and is more prone to error. We will show you next how to put all of these commands into a shell script.</p> <p>A shell script is a text file full of shell commands, that run just as if you're running them interactively at the command line.</p>"},{"location":"10.workflows-and-repeatability/#writing-a-shell-script","title":"Writing a shell script","text":"<p>Let's put some of our commands from the quality trimming module into one script.</p> <p>We'll call it <code>run_qc.sh</code>. The <code>sh</code> at the end of the tells you that this is a bash script.</p> <p>First, cd into the <code>2020-NSURP</code> directory</p> <pre><code>cd ~/2020-NSURP\n</code></pre> <p>Now, use <code>nano</code> to create and edit a file called <code>run-qc.sh</code> </p> <p><code>nano run-qc.sh</code> will open the file. Now add the following text:</p> <pre><code>cd ~/2020-NSURP\nmkdir -p quality\ncd quality\n\nln -s ~/2020-NSURP/raw_data/*.fastq.gz ./\n\nprintf \"I see $(ls -1 *.fastq.gz | wc -l) files here.\\n\"\n\nfor infile in *_R1.fastq.gz\n  do\n    name=$(basename ${infile} _R1.fastq.gz)\n    fastp --in1 ${name}_R1.fastq.gz  --in2 ${name}_R2.fastq.gz   --out1 ${name}_1.trim.fastq.gz --out2 ${name}_2.trim.fastq.gz  --detect_adapter_for_pe \\\n      --qualified_quality_phred 4  --length_required 31 --correction --json ${name}.trim.json --html ${name}.trim.html\n  done\n\n</code></pre> <p>This is now a shell script that you can use to execute all of those commands in one go, including running <code>fastp</code> on all six samples! Exit <code>nano</code> and try it out! </p> <p>Run:</p> <pre><code>cd ~/2020-NSURP\nbash run-qc.sh\n</code></pre>"},{"location":"10.workflows-and-repeatability/#re-running-the-shell-script","title":"Re-running the shell script","text":"<p>Suppose you wanted to re-run the script. How would you do that?</p> <p>Well, note that the <code>quality</code> directory is created at the top of the script, and everything is executed in that directory. So if you remove the quality directory like so,</p> <pre><code>rm -rf quality\n</code></pre> <p>The <code>-rf</code> here means that you'd like to remove the whole directory \"recursively\" (<code>r</code>) and that you'd like file deltion to happen without asking for permission for each file (<code>f</code>)</p> <p>You can then do:</p> <pre><code>bash run-qc.sh\n</code></pre>"},{"location":"10.workflows-and-repeatability/#some-tricks-for-writing-shell-scripts","title":"Some tricks for writing shell scripts","text":""},{"location":"10.workflows-and-repeatability/#make-it-executable","title":"Make it executable","text":"<p>You can get rid of the <code>bash</code> part of the command above with some magic:</p> <p>Put</p> <pre><code>#! /bin/bash\n</code></pre> <p>at the top of the file, and then run</p> <pre><code>chmod +x ~/2020-NSURP/run-qc.sh\n</code></pre> <p>at the command line.</p> <p>You can now run</p> <pre><code>./run-qc.sh\n</code></pre> <p>instead of <code>bash run-qc.sh</code>.</p> <p>You might be thinking, ok, why is this important? Well, you can do the same with R scripts and Python scripts (but put <code>/usr/bin/env Rscript</code> or <code>/usr/bin/env python</code> at the top, instead of <code>/bin/bash</code>). This basically annotates the script with the language it's written in, so you don't have to know or remember yourself.</p> <p>So: it's not necessary but it's a nice trick.</p> <p>You can also always force a script to be run in a particular language by specifying <code>bash &lt;scriptname&gt;</code> or <code>Rscript &lt;Scriptname&gt;</code>, too.</p>"},{"location":"10.workflows-and-repeatability/#automation-with-workflow-systems","title":"Automation with Workflow Systems!","text":"<p>Automation via shell script is wonderful, but there are a few problems here.</p> <p>First, you have to run the entire workflow each time and it recomputes everything every time. If you're running a workflow that takes 4 days, and you change a command at the end, you'll have to manually go in and just run the stuff that depends on the changed command.</p> <p>Second, it's very explicit and not very generalizable.  If you want to run it on a different dataset, you're going to have to change a lot of commands.</p> <p>You can read more about using workflow systems to streamline data-intensive biology in our preprint here.</p>"},{"location":"10.workflows-and-repeatability/#snakemake","title":"Snakemake","text":"<p>Snakemake is one of several workflow systems that help solve these problems. </p> <p>If you want to learn snakemake, we recommend working through a tutorial, such as the one here. It's also worth checking out the snakemake documentation here.</p> <p>Here, we'll demo how to run the same steps above, but in Snakemake.</p> <p>First, let's install snakemake in our conda environment:</p> <pre><code>conda install -y snakemake-minimal\n</code></pre> <p>We're going to automate the same set of commands for trimming, but in snakemake.</p> <p>Open a file called <code>Snakefile</code> using <code>nano</code>:</p> <pre><code>nano Snakefile\n</code></pre> <p>Here is the command we would need for a single sample, <code>CSM7KOJE</code></p> <pre><code>rule all:\n    input:\n        \"quality/CSM7KOJE_1.trim.fastq.gz\",\n        \"quality/CSM7KOJE_2.trim.fastq.gz\"\n\nrule trim_reads:\n    input:\n        in1=\"raw_data/CSM7KOJE_R1.fastq.gz\",\n        in2=\"raw_data/CSM7KOJE_R2.fastq.gz\",\n    output:\n        out1=\"quality/CSM7KOJE_1.trim.fastq.gz\",\n        out2=\"quality/CSM7KOJE_2.trim.fastq.gz\",\n        json=\"quality/CSM7KOJE.fastp.json\",\n        html=\"quality/CSM7KOJE.fastp.html\"\n    shell:\n        \"\"\"\n        fastp --in1 {input.in1}  --in2 {input.in2}  \\\n        --out1 {output.out1} --out2 {output.out2}  \\\n        --detect_adapter_for_pe  --qualified_quality_phred 4 \\\n        --length_required 31 --correction \\\n        --json {output.json} --html {output.html}\n        \"\"\"\n</code></pre> <p>We can run it like this:</p> <pre><code>cd ~/2020-NSURP\nsnakemake -n\n</code></pre> <p>the <code>-n</code> tells snakemake to run a \"dry run\" - that is, just check that the input files exist and all files specified in rule <code>all</code> can be created from the rules provided within the Snakefile).</p> <p>you should see \"Nothing to be done.\"</p> <p>That's because the trimmed files already exist!</p> <p>Let's fix that:</p> <pre><code>rm quality/CSM7KOJE*.trim.fastq.gz\n</code></pre> <p>and now, when you run <code>snakemake</code>, you should see the fastp being run. Yay w00t! Then if you run <code>snakemake</code> again, you will see that it doesn't need to do anything - all the files are \"up to date\".</p>"},{"location":"10.workflows-and-repeatability/#running-all-files-at-once","title":"Running all files at once","text":"<p>Snakemake wouldn't be very useful if it could only trim one file at a time, so let's modify the Snakefile to run more files at once:</p> <pre><code>SAMPLES = [\"CSM7KOJE\", \"CSM7KOJ0\"]\nrule all:\n    input:\n        expand(\"quality/{sample}_1.trim.fastq.gz\", sample=SAMPLES)\n        expand(\"quality/{sample}_2.trim.fastq.gz\", sample=SAMPLES)\n\nrule trim_reads:\n    input:\n        in1=\"raw_data/{sample}_R1.fastq.gz\",\n        in2=\"raw_data/{sample}_R2.fastq.gz\",\n    output:\n        out1=\"quality/{sample}_1.trim.fastq.gz\",\n        out2=\"quality/{sample}_2.trim.fastq.gz\",\n        json=\"quality/{sample}.fastp.json\",\n        html=\"quality/{sample}.fastp.html\"\n    shell:\n        \"\"\"\n        fastp --in1 {input.in1}  --in2 {input.in2}  \\\n        --out1 {output.out1} --out2 {output.out2}  \\\n        --detect_adapter_for_pe  --qualified_quality_phred 4 \\\n        --length_required 31 --correction \\\n        --json {output.json} --html {output.html}\n        \"\"\"\n</code></pre> <p>Try another dryrun:</p> <pre><code>snakemake -n\n</code></pre> <p>Now actually run the workflow:</p> <pre><code>snakemake -j 1\n</code></pre> <p>the <code>-j 1</code> tells snakemake to run a single job at a time. You can increase this number if you have access to more cpu (e.g. you're in an <code>srun</code> session where you asked for more cpu with the <code>-n</code> parameter).</p> <p>Again, we see there's nothing to be done - the files exist!  Try removing the quality trimmed files and running again.</p> <pre><code>rm quality/*.trim.fastq.gz\n</code></pre>"},{"location":"10.workflows-and-repeatability/#adding-an-environment","title":"Adding an environment","text":"<p>We've been using a conda environment throughout our modules.  We can export the installed package names to a file that we can use to re-install all packages in a single step (like on a different computer). </p> <pre><code>conda env export -n nsurp-env -f ~/2020-NSURP/nsurp-environment.yaml\n</code></pre> <p>We can use this environment in our snakemake rule as well!</p> <pre><code>SAMPLES = [\"CSM7KOJE\", \"CSM7KOJ0\"]\n\nrule all:\n    input:\n        expand(\"quality/{sample}_1.trim.fastq.gz\", sample=SAMPLES)\n        expand(\"quality/{sample}_2.trim.fastq.gz\", sample=SAMPLES)\n\nrule trim_reads:\n    input:\n        in1=\"raw_data/{sample}_R1.fastq.gz\",\n        in2=\"raw_data/{sample}_R2.fastq.gz\",\n    output:\n        out1=\"quality/{sample}_1.trim.fastq.gz\",\n        out2=\"quality/{sample}_2.trim.fastq.gz\",\n        json=\"quality/{sample}.fastp.json\",\n        html=\"quality/{sample}.fastp.html\"\n    conda: \"nsurp-environment.yaml\"\n    shell:\n        \"\"\"\n        fastp --in1 {input.in1}  --in2 {input.in2}  \\\n        --out1 {output.out1} --out2 {output.out2}  \\\n        --detect_adapter_for_pe  --qualified_quality_phred 4 \\\n        --length_required 31 --correction \\\n        --json {output.json} --html {output.html}\n        \"\"\"\n</code></pre> <p>Here, we just have a single environment, so it was pretty easy to just run the Snakefile while within our <code>nsurp-env</code> environment. Using conda environment with snakemake becomes more useful as you use more tools, because it helps to keep different tools (which likely have different software dependencies) in separate conda environments.</p> <p>Run snakemake with <code>--use-conda</code> to have snakemake use the conda environment for this step.</p> <pre><code>snakemake -j 1 --use-conda\n</code></pre>"},{"location":"10.workflows-and-repeatability/#why-automate-with-workflow-systems","title":"Why Automate with Workflow Systems?","text":"<p>Workflow systems contain powerful infrastructure for workflow management that can coordinate runtime behavior, self-monitor progress and resource usage, and compile reports documenting the results of a workow. These features ensure that the steps for data analysis are minimally documented and repeatable from start to finish.  When paired with proper software management, fully-contained workows are scalable, robust to software updates, and executable across platforms, meaning they will likely still execute the same set of commands with little investment by the user after weeks, months, or years.</p> <p>Check out our workflows preprint for a guide.</p>"},{"location":"11.experiment-challenge/","title":"Experiment Challenge","text":"<p>Thus far, we've run through a set of commands with six metagenome samples.  These have been from two patients, one with Crohn's disease, one without. But there's not much we can say with just two patients (other than \"they look different!\").</p> <p>Now, we'll add samples from more patients and try to understand the differences between samples.</p>"},{"location":"11.experiment-challenge/#workspace-setup","title":"Workspace Setup","text":"<p>If you're starting a new work session on FARM, be sure to follow the instructions here.</p>"},{"location":"11.experiment-challenge/#download-additional-files","title":"Download Additional Files","text":"<p>Move into the raw data folder</p> <pre><code>cd ~/2020-NSURP/raw_data\n</code></pre> <p>Download the files</p> <pre><code>wget https://ibdmdb.org/downloads/raw/HMP2/MGX/2018-05-04/CSM7KOJO.tar\nwget https://ibdmdb.org/downloads/raw/HMP2/MGX/2018-05-04/HSMA33R1.tar\nwget https://ibdmdb.org/downloads/raw/HMP2/MGX/2018-05-04/HSMA33R5.tar\n\nwget https://ibdmdb.org/downloads/raw/HMP2/MGX/2018-05-04/MSM6J2QP.tar\nwget https://ibdmdb.org/downloads/raw/HMP2/MGX/2018-05-04/MSM6J2QF.tar\nwget https://ibdmdb.org/downloads/raw/HMP2/MGX/2018-05-04/MSM6J2QH.tar\n</code></pre> <p>Untar each read set</p> <pre><code>tar xf HSMA33S4.tar\n</code></pre>"},{"location":"11.experiment-challenge/#trim-and-compute-sourmash-signatures-for-these-files","title":"Trim and compute sourmash signatures for these files","text":"<p>Using your HackMD notes, run the commands for trimming (both adapter and k-mer trimming) on these samples.</p> <p>For reference, the Quality Control contains code for running <code>fastp</code> and <code>khmer</code> trimming; the Comparing Samples with Sourmash contains code for computing sourmash signatures.</p>"},{"location":"11.experiment-challenge/#run-sourmash-compare","title":"Run Sourmash Compare","text":"<p>Run <code>sourmash compare</code> and <code>sourmash plot</code> (as in Comparing Samples with Sourmash).</p> <p>What do you notice about the sourmash comparison heatmap?</p> <p>Which samples are more similar to each other?  Can you guess which patients have Crohn's disease or no IBD by comparing them to your prior samples? How do samples from the same patient compare to samples from different patients?</p>"},{"location":"11.experiment-challenge/#assess-taxonomic-diversity","title":"Assess Taxonomic Diversity","text":"<p>Run <code>sourmash gather</code> with the <code>genbank-k31</code> database on these new samples. </p> <p>Count the total number of species found in each sample. Does it differ between Crohn's disease and non-IBD patients?</p>"},{"location":"11.experiment-challenge/#look-at-the-sample-metadata","title":"Look at the sample metadata","text":"<p>What additional information can you glean from looking at the metadata (the data about the data)?</p> <p>As usual, let's start by creating a directory for this</p> <pre><code>mkdir -p ~/2020-NSURP/metadata\ncd ~/2020-NSURP/metadata\n</code></pre> <p>All information about this project can be found here.</p> <p>Download the metadata file here.</p> <p>This file contains information for the metagenomics sequencing (which we looked at), but also a number of other assessments.</p> <p>This file is a spreadsheet that can be opened in Google docs or viewed with <code>less</code>.</p> <p>For example, view this file with less like so:</p> <pre><code>less -S hmp2_metadata_2018-08-20.csv\n</code></pre> <p>This is a very large file. You can get information about a specific sample by searching out the specific sample id's we used. For example:</p> <pre><code>grep HSMA33S4 hmp2_metadata_2018-08-20.csv\n</code></pre> <p>That's still a lot of info - let's get only the info for metagenomics samples:</p> <pre><code>grep metagenomics hmp2_metadata_2018-08-20.csv | grep HSMA33S4\n</code></pre> <p>The formatting is still a litle ugly.  Let's direct the output to a file, and then open it with <code>less -S</code>:</p> <pre><code>grep metagenomics hmp2_metadata_2018-08-20.csv | grep HSMA33S4 &gt; HSMA33S4.csv\nless -S HSMA33S4.csv\n</code></pre>"},{"location":"12.angus-github/","title":"Version Control with Github","text":"<p>Learning objectives</p> <ul> <li>Learn about version Control</li> <li>Learn about Github repositories</li> <li>Create local repositories</li> <li>Backup your work online using git</li> </ul>"},{"location":"12.angus-github/#setup","title":"Setup","text":"<p>You\u2019ll need to sign up for a free account on GitHub.com. It\u2019s as simple as signing up for any other social network. Keep the email you picked handy; we\u2019ll be referencing it again in the lesson.</p> <p><code>Git</code> is installed on many system, but if you don't already have it, instructions to install Git for Windows, Mac or Linux can be found here.</p>"},{"location":"12.angus-github/#what-is-github","title":"What is Github?","text":"<p>GitHub is a code hosting platform for version control and collaboration. It lets you and others work together on projects from anywhere. GitHub is now the largest online storage space of collaborative works that exists in the world</p>"},{"location":"12.angus-github/#what-is-git","title":"What Is Git?","text":"<p>Why use something like Git? Say you and a coworker are both updating pages on the same website. You make your changes, save them, and upload them back to the website. So far, so good. The problem comes when your coworker is working on the same page as you at the same time. One of you is about to have your work overwritten and erased.</p> <p>A version control application like Git keeps that from happening. You and your coworker can each upload your revisions to the same page, and Git will save two copies. Later, you can merge your changes together without losing any work along the way. You can even revert to an earlier version at any time, because Git keeps a \u201csnapshot\u201d of every change ever made.</p>"},{"location":"12.angus-github/#git-terms","title":"Git terms","text":""},{"location":"12.angus-github/#repository","title":"Repository:","text":"<p>A directory or storage space where your projects can live. Sometimes GitHub users shorten this to \u201crepo.\u201d It can be local to a folder on your computer, or it can be a storage space on GitHub or another online host. You can keep code files, text files, image files, you name it, inside a repository.</p>"},{"location":"12.angus-github/#version-control","title":"Version Control:","text":"<p>Basically, the purpose Git was designed to serve. When you have a Microsoft Word file, you either overwrite every saved file with a new save, or you save multiple versions. With Git, you don\u2019t have to. It keeps \u201csnapshots\u201d of every point in time in the project\u2019s history, so you can never lose or overwrite it.</p>"},{"location":"12.angus-github/#commit","title":"Commit:","text":"<p>This is the command that gives Git its power. When you commit, you are taking a \u201csnapshot\u201d of your repository at that point in time, giving you a checkpoint to which you can reevaluate or restore your project to any previous state.</p>"},{"location":"12.angus-github/#branch","title":"Branch:","text":"<p>How do multiple people work on a project at the same time without Git getting them confused? Usually, they \u201cbranch off\u201d of the main project with their own versions full of changes they themselves have made. After they\u2019re done, it\u2019s time to \u201cmerge\u201d that branch back with the \u201cmaster,\u201d the main directory of the project.</p> <p></p>"},{"location":"12.angus-github/#git-specific-commands","title":"Git-Specific Commands","text":"<p><code>git init</code>: Initializes a new Git repository. Until you run this command inside a repository or directory, it\u2019s just a regular folder. Only after you input this does it accept further Git commands.</p> <p><code>git config</code>: Short for \u201cconfigure,\u201d this is most useful when you\u2019re setting up Git for the first time.</p> <p><code>git help</code>: Forgot a command? Type this into the command line to bring up the 21 most common git commands. You can also be more specific and type \u201cgit help init\u201d or another term to figure out how to use and configure a specific git command.</p> <p><code>git status</code>: Check the status of your repository. See which files are inside it, which changes still need to be committed, and which branch of the repository you\u2019re currently working on.</p> <p><code>git add</code>: This does not add new files to your repository. Instead, it brings new files to Git\u2019s attention. After you add files, they\u2019re included in Git\u2019s \u201csnapshots\u201d of the repository.</p> <p><code>git commit</code>: Git\u2019s most important command. After you make any sort of change, you input this in order to take a \u201csnapshot\u201d of the repository. Usually it goes <code>git commit -m \u201cMessage here.\u201d</code> The <code>-m</code> indicates that the following section of the command should be read as a message.</p> <p><code>git branch</code>: Working with multiple collaborators and want to make changes on your own? This command will let you build a new branch, or timeline of commits, of changes and file additions that are completely your own. Your title goes after the command. If you wanted a new branch called \u201ccats,\u201d you\u2019d type <code>git branch cats</code>.</p> <p><code>git checkout</code>: Literally allows you to \u201ccheck out\u201d a repository that you are not currently inside. This is a navigational command that lets you move to the repository you want to check. You can use this command as g<code>it checkout master</code> to look at the master branch, or <code>git checkout cats</code> to look at another branch.</p> <p><code>git merge</code>: When you\u2019re done working on a branch, you can merge your changes back to the master branch, which is visible to all collaborators. <code>git merge cats</code> would take all the changes you made to the \u201ccats\u201d branch and add them to the master.</p> <p><code>git push</code>: If you\u2019re working on your local computer, and want your commits to be visible online on GitHub as well, you \u201cpush\u201d the changes up to GitHub with this command.</p> <p><code>git pull</code>: If you\u2019re working on your local computer and want the most up-to-date version of your repository to work with, you \u201cpull\u201d the changes down from GitHub with this command.</p>"},{"location":"12.angus-github/#setting-up-github-and-git-for-the-first-time","title":"Setting Up GitHub And Git For The First Time","text":"<p>It\u2019s time to introduce yourself to Git. Type in the following code:</p> <pre><code>git config --global user.name \"Your Name Here\"\n</code></pre> <p>Next, tell it your email and make sure it\u2019s the same email you used when you signed up for a GitHub.com account</p> <pre><code>git config --global user.email \"your_email@youremail.com\"\n</code></pre>"},{"location":"12.angus-github/#creating-your-online-repository","title":"Creating Your Online Repository","text":"<p>Now that you\u2019re all set up, it\u2019s time to create a place for your project to live. Both Git and GitHub refer to this as a repository, or \u201crepo\u201d for short, a digital directory or storage space where you can access your project, its files, and all the versions of its files that Git saves.</p> <ul> <li>On your Github profile, click the plus button and select a \"New Repository\".</li> </ul> <p></p> <ul> <li> <p>Give your repository a name &amp; fill out the necessary information for your repository to be distinct and recognizeable.</p> </li> <li> <p>Don\u2019t worry about clicking the checkbox next to \u201cInitialize this repository with a README.\u201d A Readme file is usually a text file that explains a bit about the project. But we can make our own Readme file locally for practice.</p> </li> <li> <p>Click the green \u201cCreate Repository\u201d button and you\u2019re set. You now have an online space for your project to live in.</p> </li> </ul> <p></p>"},{"location":"12.angus-github/#creating-your-local-repository","title":"Creating Your Local Repository","text":"<p>To begin, let's create a new directory called MyProject.</p> <pre><code>mkdir ~/MyProject\n</code></pre> <p>Then we will move into this new directory.</p> <pre><code>cd ~/MyProject\n</code></pre> <p>To create a local repository, we will first initiate a new repository for \"MyProject\" by entering the following command:</p> <pre><code>git init\n</code></pre> <p><code>touch</code> is a multi-purpose command, but one of its key uses is to creat new, empty files. In our case, we will create a new file called Readme.txt. </p> <pre><code>touch Readme.txt\n</code></pre> <p>We can check the status of our new repository by using <code>git status</code>.  </p> <pre><code>git status\n</code></pre> <p>When we want Git to track a file, we use <code>git add</code> followed by the file we want Git to \"see\". If we do not use <code>git add</code>, Git will not \"see\" this file.</p> <pre><code>git add Readme.txt\n</code></pre> <p>Lastly, to have Git track the current \"snapshot\" of our file, we enter <code>git commit</code>. The <code>-m</code> flag allows us to add a personal message with the files we are committing. In the following example, our message is \"Add Readme.txt\". Examples of other messages could include version information, changes made to a document, document descriptions, etc. </p> <pre><code>git commit -m \u201cAdd Readme.txt\u201d\n</code></pre> <p>Now Git has a \"snapshot\" of this version of Readme.txt which you can return to at any time in the future!</p> <p></p>"},{"location":"12.angus-github/#connect-your-local-repository-to-your-github-repository-online","title":"Connect Your Local Repository To Your GitHub Repository Online","text":"<p>This setup also makes it easy to have multiple collaborators working on the same project. Each of you can work alone on your own computers, but upload or \u201cpush\u201d your changes up to the GitHub repository when they\u2019re ready.</p> <p>To tell Git the address off your remote repo in Github, Type the following replacing the address of the repo with your own</p> <pre><code>git remote add origin https://github.com/username/myproject.git\n</code></pre> <p>Git now knows there\u2019s a remote repository and it\u2019s where you want your local repository changes to go. To confirm, type this to check:</p> <pre><code>git remote -v\n</code></pre> <p>Great, Git is able to connect with our remote on Github. So, let's go ahead and push our files to Github</p> <pre><code>git push origin master\n</code></pre> <p>You will be prompted for your Github username and password at this point</p> <p>and you can see some output like this that git is sending packets of data to your github repo and by this you will force git to back up all of your commits since the last time you pushed to be backed up online. FOR FREE!</p> <pre><code>Counting objects: 3, done.\nWriting objects: 100% (3/3), 217 bytes | 217.00 KiB/s, done.\nTotal 3 (delta 0), reused 0 (delta 0)\nTo https://github.com/sateeshbio5/angus_test.git\n * [new branch]      master -&gt; master\n\n</code></pre> <p>Note: To avoid having to type your username and password each time you push/pull from your github repos, read about Secure Login here</p> <p></p>"},{"location":"12.angus-github/#collaborating-via-github","title":"Collaborating via GitHub","text":"<ul> <li>GitHub Issues: Issues are a great way to keep track of tasks, enhancements, and bugs for your projects. They\u2019re kind of like email\u2014except they can be shared and discussed with all. Read more about Mastering Issues on Github here</li> </ul> <ul> <li>GitHub Pull-Requests: Pull requests let you tell others about changes you've pushed to a branch in a repository on GitHub. Once a pull request is opened, you can discuss and review the potential changes with collaborators and add follow-up commits before your changes are merged into the base branch.</li> </ul> <p>Look at others' repositories:</p> <ul> <li> <p>Hadley Wickham (ggplot2)</p> </li> <li> <p>Yihui Xie (knitr)</p> </li> <li> <p>ANGUS 2019</p> </li> </ul>"},{"location":"12.angus-github/#host-websites-blogs-on-github","title":"Host Websites &amp; Blogs on GitHub","text":"<ul> <li> <p>GitHub Pages is an awesome feature that lets you host websites/blogs for you and your projects.</p> </li> <li> <p>Hosted directly from your GitHub repository. Just edit, push, and your changes are live.</p> </li> <li> <p>Read more about GitHub Pages here</p> </li> </ul>"},{"location":"12.angus-github/#sources-for-this-tutorial-additional-git-resources","title":"Sources for this tutorial &amp; Additional Git Resources","text":"<ul> <li> <p>Introductory tutorial by Lauren Orsini here</p> </li> <li> <p>Pro Git</p> </li> <li> <p>Try Git</p> </li> <li> <p>Github Guides</p> </li> <li> <p>Github Reference</p> </li> <li> <p>Git - Simple Guide</p> </li> <li> <p>Github Hello World</p> </li> </ul>"}]}